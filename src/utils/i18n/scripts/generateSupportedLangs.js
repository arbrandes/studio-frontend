#!/usr/bin/env node

const scriptHelpDocument = `
NAME
  generateSupportedLangs.js â€” Script to generate the 'src/i18n/messages/currentlySupportedLangs.jsx' file which contains static import for react-intl data.

SYNOPSIS
  generateSupportedLangs.js [-h | --help] MESSAGES_DIR


DESCRIPTION

  Run this script after 'atlas' has pulled the files in the following structure:  

    $ node src/utils/i18n/scripts/generateSupportedLangs.js src/i18n/messages

  This script will generate the 'src/i18n/messages/currentlySupportedLangs.jsx' file which contains static import for 
  react-intl data based on the JSON language files present in the 'src/i18n/messages' directory.

  This script is intended as a temporary solution until the studio-frontend can dynamically load the languages from the react-intl data like the other micro-frontends.
`;

const fs = require('fs');
const path = require('path');

const loggingPrefix = path.basename(`${__filename}`); // the name of this JS file

// Header note for generated src/i18n/index.js file
const filesCodeGeneratorNoticeHeader = '// This file is generated by the "generateSupportedLangs.js" script.';

/**
 * Create main `src/i18n/index.js` messages import file.
 *
 *
 * @param languages - List of directories with a boolean flag whether its "index.js" file is written
 *                               The format is "[\{ directory: "frontend-component-example", isWritten: false \}, ...]"
 * @param writeFileSync - Mockable fs.writeFileSync
 * @param i18nDir` - Path to `src/i18n` directory
 */
function generateSupportedLangsFile({
  languages,
  writeFileSync,
  i18nMessagesDir,
}) {
  const exportLines = [];
  let importLines = [];

  languages.forEach(language => {
    const [languageFamilyCode] = language.split('_'); // Get `es` from `es-419`

    const importVariableName = `${languageFamilyCode.toLowerCase()}Data`;
    const dashLanguageCode = language.toLowerCase().replace(/_/g, '-');
    importLines.push(`import ${importVariableName} from 'react-intl/locale-data/${languageFamilyCode}';`);
    exportLines.push(`  '${dashLanguageCode}': ${importVariableName},`);
  });

  importLines = Array.from(new Set(importLines)); // Remove duplicates
  importLines.sort(); // Ensure consistent file output

  // See the help message above for sample output.
  const indexFileContent = [
    filesCodeGeneratorNoticeHeader,
    importLines.join('\n'),
    '\nexport default {',
    exportLines.join('\n'),
    '};\n',
  ].join('\n');

  writeFileSync(`${i18nMessagesDir}/currentlySupportedLangs.jsx`, indexFileContent);
}

/*
 * Main function of the file.
 */
function main({
  log,
  writeFileSync,
  i18nMessagesDir,
}) {
  if (!i18nMessagesDir) {
    log(scriptHelpDocument);
    log(`${loggingPrefix}: Error: The "MESSAGES_DIR" parameter is required.\n`);
    return false;
  }

  if (i18nMessagesDir === '-h' || i18nMessagesDir === '--help') {
    log(scriptHelpDocument);
    return true;
  }

  const languageFiles = fs.readdirSync(`${i18nMessagesDir}`).filter(file => file.endsWith('.json'));
  const languages = languageFiles.map(file => file.replace('.json', ''));
  languages.sort();

  if (!languages.length) {
    log(scriptHelpDocument);
    log(`${loggingPrefix}: Error: No language files found in the "${i18nMessagesDir}"'.\n`);
    return false;
  }

  generateSupportedLangsFile({
    languages,
    writeFileSync,
    i18nMessagesDir,
  });
  log(`${loggingPrefix}: Finished generating the 'currentlySupportedLangs.jsx' file.\n`);
  return true;
}

// istanbul ignore next
if (require.main === module) {
  // Run the main() function if called from the command line.
  const success = main({
    i18nMessagesDir: process.argv[2],
    log: text => process.stdout.write(text),
    writeFileSync: fs.writeFileSync,
  });

  process.exit(success ? 0 : 1);
}

module.exports.main = main; // Allow tests to use the main function.
